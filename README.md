This ReadME is NOT FINAL See Wiki!
# FAQ:

  

>[!note]

>You can also use other templates or technology stacks.

>e.g UGS from Michl Bayer, the spring firebase framework.

>Other versions with firebase or custom server should be ok, but ask the tutor beforehand just in case!

  
  

>[!warning]

>no guide to manual port forwarding will be given since it depends on your own setup!

  

## Technology Stack

[**WebsocketC#**](https://github.com/sta/websocket-sharp)

  

[**Serveo**](https://serveo.net/) or [Ngrok](https://ngrok.com/download)

  

[**Django**](https://www.djangoproject.com/)

  

[**Unity**](https://unity.com/de)

  
  

# Installation

## Unity

There are 4 ways for installing the unity project:

- using the provided unitypackage

- downloading the project template (.tgz)

- downloading/cloning from git

- importing everything manually (not recommended!)

  

## Django

install python 3.10 and install the packages from the requirements.txt

```

ngrok~=1.2.0  

channels~=4.0.0  

Django~=5.0.3  

asgiref~=3.8.0  

websockets~=12.0  

daphne~=4.1.0

```

python3 -m pip install channels_redis

pip3 install -U channels["daphne"]

  

## Port forwarding solutions

### [Serveo](http://serveo.net/)

just type in an cmd/powershell/terminal following command

`ssh -R 80:localhost:8000 serveo.net`

it will give you a random public url

![[Pasted image 20240320211208.png]]

*This url was NOT intended but funny ^^*

  

I would recommend to use a static url, so you don't need to change it everytime in the unity project.

use the following command

`ssh -R subdomain:80:127.0.0.1:8000 serveo.net       `

results in

`https://subdomain.serveo.net`

You potentially need to add an ssh key* see the output for more information

  

### [Ngrok](https://ngrok.com/)

  

Create an account etc. and create your FREE domain

https://dashboard.ngrok.com/

![[Pasted image 20240320211806.png]]

under https://dashboard.ngrok.com/get-started/setup/windows

you can see instructions how to download it on WINDOWS and run it with a random and static URL

DON'T FORGET THE AUTHTOKEN!

This is not the SAME as the part from the requirements.txt in [[#Django]]

  

### [Pythonanywhere](https://www.pythonanywhere.com/)

During begin of developing this template ASGI was not supported

https://www.pythonanywhere.com/forums/topic/30868/

  

Since 2024 there is a beta version:

https://help.pythonanywhere.com/pages/FastAPI/

I did not try the beta version!

  

If you don't want the Websocket part you can delete all websocket parts and just use the rest part.

#TODO anleitung

  
  
  
  
  

====================================================

#TODO #deprecated

- [x] installation

- [x] project structure

- [x] rest

    - [x] unity

    - [x] django

- [x] Websockets

- [ ] How to add own things

- [x] Short FAQ

- [ ] Misc.

  

# Unity side structure: #deprecated

In the project there are already two plugins/dll files.

- [websocket c#](https://github.com/sta/websocket-sharp)

- [Newtonsoft Json](https://www.newtonsoft.com/json)

  

With these plugins there is a support for websockets and better json usage during development.

  

> [!info]
> The JsonUtility from unity which is already installed, cannot deserialize List<T> stuff! #TODO

  
  

Scenes:

    3DPosSync: Based on websocket "realtime"sync of randompositions between the players in the same lobby

    WSShowcase: A showcase of the script usages for Websockets.

  

Scripts: all of them works with their counterpart on the python/django side!

    - BasicRest: Basic Communication by asking the url with some POST variables, like the other Unity/Django Template.

    - BasicWebsockets: a basic implementation of the communication between unity and Django based on websockets.

    - ServerClasses: The unity side of the django models. to make our lives easier with Serialization etc. (save/send classes as a whole instead of single data snippets)

  

## Django side structure:

django_part:  the folder where the python stuff is!

    django_part: generic django project settings!

    staticfiles static files like CSS/JS files (generated by django)

    templates: Html files if you want to add a webinterface

    WSSGTemplate: Your project specific files! like the models, routing/url stuff and the logic behind your server

  

## HOW TO:

every CAPS variable is something YOU need to SET somehow.

  

> [!hint]
>- You don't need to follow any structure, coding style or logic from these examples!
>- Every communication should be in JSON or some similar structure!
>- Otherwise the codequality can very quickly suffer. And just send everything in plain text, **security doesn't count here**.

  

Send message, Client => Server, WWWForm, REST

```cs

var form = new WWWForm();

form.AddField("username", USERNAME);

form.AddField("password", PASSWORD);

//add more variables

using (var www = UnityWebRequest.Post(URL, form))

{

    yield return www.SendWebRequest();

    if (www.result != UnityWebRequest.Result.Success)

    {

        Debug.Log(www.error);

    }

    else

    {

        Debug.Log("ServerResponse: " + www.downloadHandler.text); // www.downloadHandler.text is a string!

        DoStuff(www.downloadHandler.text); // method for more readable and maintanable code

    }

}

```

  

Send message, Client => Server, Dictionary, REST

```cs

var values = new Dictionary<string, object>{{"username", USERNAME},{"password", PASSWORD},...};

using (var www = UnityWebRequest.Post(URL, JsonConvert.SerializeObject(values), "application/json"))

{

    yield return www.SendWebRequest();

    if (www.result != UnityWebRequest.Result.Success)

    {

        Debug.Log(www.error);

    }

    else

    {

        Debug.Log("ServerResponse: " + www.downloadHandler.text); // www.downloadHandler.text is a string!

        DoStuff(www.downloadHandler.text); // method for more readable and maintanable code

    }

}

```

  

Send Message, get RESPONSE from Server, Client => Server, REST

```cs

//UNITY

var values = new Dictionary<string, object>{{"username", USERNAME},{"password", PASSWORD},...};

using (var www = UnityWebRequest.Post(URL, JsonConvert.SerializeObject(values), "application/json"))

{

    yield return www.SendWebRequest();

    if (www.result != UnityWebRequest.Result.Success)

    {

        Debug.Log(www.error);

    }

    else

    {

        Debug.Log("ServerResponse: " + www.downloadHandler.text); // www.downloadHandler.text is a string!

        DoStuff(www.downloadHandler.text); // method for more readable and maintanable code

    }

}

```

  

```python

#in WSSGTemplate>rest_scripts>urls_rest.py

urlpatterns = [

...

path(URL,views_FILENAME.METHOD)

]

  

#in WSSGTemplate>rest_scripts>views_FILENAME

  

def METHOD(request):

    return HTTPResponse("Hello World")

```

  

Database stuff:

```python

#in WSSGTemplate>models.py

from django.contrib.auth.models import User

from django.db import models

  

class ExampleClass(models.Model):

    uid= modles.AutoField(primary_key=True)

    user= models.OneToOneField(User, on_delete=models.CASCADE)

    name= models.CharField(max_length=420, default="SOME_VALUE")

    age=models.IntegerField(default=42)

    location_x=models.FloatField(default=0.0)

    location_y=models.FloatField(default=0.0)

  

#in WSSGTemplate>admin.py

from WSSGTemplate.models import *

admin.site.register(ExampleClass)

  
  

#in WSSGTemplate>rest_scripts>views_FILENAME

  

def METHOD(request):

    #get a specific object of ExampleClass

    example_obj=ExampleClass.objects.get(uid=UID_VALUE)

    #get a specific object of ExampleClass and creation, if non existent

example_obj=ExampleClass.objects.get_or_create(uid=UID_VALUE)

  

    #get ALL objects of ExampleClass

    example_objs= ExampleClass.objects.all()

    #Depending on the structure of the return value, one may need to restructure it.

  

    #change some values

    example_obj.name= "Max Mustermann"

    example_obj.age=69

  

    #save the object otherwise it WON'T appear in the database

    example_obj.save()

```

  

Send Message, Server-> Client

Since the Server does not have an active connection to the Client,

the Client needs to request the data and use the response by the Server!

  

```cs

var form = new WWWForm();

using (var www = UnityWebRequest.Post(REQUEST_URL, form))

{

    yield return www.SendWebRequest();

    if (www.result != UnityWebRequest.Result.Success)

    {

        Debug.Log(www.error);

    }

    else

    {

        Debug.Log("ServerResponse: " + www.downloadHandler.text); // www.downloadHandler.text is a string!

        DoStuff(www.downloadHandler.text); // method for more readable and maintanable code

    }

}

```

  

```python

#in WSSGTemplate>rest_scripts>urls_rest.py

urlpatterns = [

...

path(REQUEST_URL,views_FILENAME.METHOD)

]

  

#in WSSGTemplate>rest_scripts>views_FILENAME

  

def METHOD(request):

    return HTTPResponse("Hello World")

```

  

some basic checks, django

```python

  

def basic_request_check(request):

  

    if request.method != 'POST':

  

        return HttpResponse(f'incorrect request method.')

  

    if not request.user.is_authenticated:

  

        return HttpResponse(f'user not signed in')

  

    if not hasattr(request.user, 'player'):

  

        return HttpResponse(f'user not found, are you logged in?')

  

    return None

...

def METHOD(request):

    example_obj=ExampleClass.objects.get(uid=UID_VALUE)

    if example_obj is None:

         return HttpResponse(f'Object with UID {UID_VALUE} not found')

```

  

other short tips

- if sending booleans one need to do some conversions, since in C# it's true and false but in Python it's True and False

- I used this method to convert the objects to Json. #TODO

```python

  

from django.core import serializers

def get_json_from_record(record):

  

    serialized_obj = serializers.serialize('json', [record])

  

    test_json = json.loads(serialized_obj)

  

    return test_json[0]["fields"]

```

## Code explained!

### important methods

#### unity

```cs

  public async Task GenericSendAsync(string url, Dictionary<string, object> values, ServerRequestCallBack callback = null)

    {

            //little safety check

        if (!url.StartsWith(TemplateSettings.url))

            url = TemplateSettings.url + url;

        using (var www = UnityWebRequest.Post(url, JsonConvert.SerializeObject(values), "application/json"))

        {

            www.SendWebRequest();

            while (!www.isDone)

                await Task.Yield();

            if (www.downloadHandler.text.IsNullOrEmpty())

                throw new Exception("Server did not respond. Is the server up? or does it receive the request?");  

                              callback?.Invoke(JsonConvert.DeserializeObject<ServerMessage>(www.downloadHandler.text));

        }

    }

public async Task GenericRequestAsync(string url, ServerRequestCallBack callback = null)

{

    //little safety check

        if (!url.StartsWith(TemplateSettings.url))

            url = TemplateSettings.url + url;

        using (var www = UnityWebRequest.PostWwwForm(url, ""))

        {

            www.SendWebRequest();

            while (!www.isDone)

                await Task.Yield();

            if (www.downloadHandler.text.IsNullOrEmpty())

                throw new Exception("Server did not respond. Is the server up? or does it receive the request?");

                            callback?.Invoke(JsonConvert.DeserializeObject<ServerMessage>(www.downloadHandler.text));

        }

        }

```

>[!info]
>- GenericSendAsync **SENDS** data to the server and handles the response via the callback
>- GenericRequestAsync **ONLY REQUEST** data from the server and handles the reponse via the callback
>- In the ServerCaller.cs File are MULTIPLE different versions of these two methods. Depending on what you like to use!

  

#### Django/python

>[!info] extract request value
>```py
>def extract_request_value(request, variable_name):
>    try:
>        content_type = request.content_type.lower()
>        if 'application/json' in content_type:
>            post_data = json.loads(request.body)
>            return post_data.get(variable_name)
>        elif 'application/x-www-form-urlencoded' in content_type:
>            post_data = parse_qs(request.body.decode("utf-8"))
>            return post_data.get(variable_name, [])[0]
>    except:
>        print("variable_name is probably wrong or it doesn't exist! error for:" + variable_name)
>        return None
>```

Depending on json or x-www-form-urlencoded it extracts the value if available and returns it

  
  
  

>[!info] server message response
>
>| identifier | usage                 | status code |
>| ---------- | --------------------- | ----------- |
>| MESSAGE    | display in e.g. popup | 200         |
>| DATA       | use the data somehow  | 200         |
>| NOTHING    | ignorable messages    | 200         |
>| ERROR      | error                 | 400         |
>| WARNING    | warning               | 200         |
> ```py
>#default is set to ERROR message
>def server_message_response(message, identifier="ERROR", extra_message="server", status=400):
>    # if want to track everything safe the ServerMessages in models.
>    return HttpResponse(server_message_json(message=message, identifier=identifier, extra_message=extra_message),           status=status)
>```
server_message_json is just a converter into json. In theory it could also be the model!

  
  

> [!info] instance of model => json
>```py
>def get_json_from_instance(instance):
>    serialized_obj = serializers.serialize('json', [instance])
>    test_json = json.loads(serialized_obj)
>    return test_json[0]["fields"]
>```
 just a shortcut for 3 lines

  

>[!info] generic get for models
>```py
>def search_object_by_attribute(server_class, **kwargs):
>    try:
>        match server_class:
>            case ServerClass.Player:
>                return  Player.objects.get(**kwargs)
>            case ServerClass.Friendship:
>                return Friendship.objects.get(**kwargs)
>            case ServerClass.FriendRequest:
>                return FriendRequest.objects.get(**kwargs)
>            case ServerClass.Inventory:
>                return Inventory.objects.get(**kwargs)
>            case ServerClass.Lobby:
>                return Lobby.objects.get(**kwargs)
>            case ServerClass.TTTGame:
>                return TTTGame.objects.get(**kwargs)
>            case ServerClass.Guild:
>               return Guild.objects.get(**kwargs)
>            case ServerClass.ServerMessage:
>                return ServerMessage.objects.get(**kwargs)
>            case ServerClass.Leaderboard:
>                return Leaderboard.objects.get(**kwargs)
>            case _:
>                return None  # Handle unsupported server >class
>    except Exception as e:
>        print("error\n", e)
>        return None  # Handle exceptions such as >ObjectDoesNotExist or others
>```
>> [!info] Python version < 3.10
>> ```py
>> if server_class == ServerClass.Player:
>>    return Player.objects.get(**kwargs)
>> elif server_class == ServerClass.Friendship:
>>    return Friendship.objects.get(**kwargs)
>> elif server_class == ServerClass.FriendRequest:
>>    return FriendRequest.objects.get(**kwargs)
>> elif server_class == ServerClass.Inventory:
>>    return Inventory.objects.get(**kwargs)
>> elif server_class == ServerClass.Lobby:
>>    return Lobby.objects.get(**kwargs)
>> elif server_class == ServerClass.TTTGame:
>>    return TTTGame.objects.get(**kwargs)
>> elif server_class == ServerClass.Guild:
>>    return Guild.objects.get(**kwargs)
>> elif server_class == ServerClass.ServerMessage:
>>    return ServerMessage.objects.get(**kwargs)
>> elif server_class == ServerClass.Leaderboard:
>>    return Leaderboard.objects.get(**kwargs)
>> else:
>>   return None  # Handle unsupported server class
>> ```


### routing/urls

first on Django side one need to configure the urls by which the logic should be callable.

For that go to WSSGTemplate-> urls_rest.py / urls_ws.py

in these two files you can see the single path to methods patterns.

the rest part is callable under `your_adress:8000/rest/XY`

the websocket part is callable under `your_adress:8000/ws/XY`

XY are the paths which are in the urlpatterns of the respective file. The prefix of rest  or ws is set under

*django_part-> django_part->urls.py*

  

Please make sure to configure these urls correctly especially with the trailing in urls */* or lower/upper case!

  

### REST

The most simple version for a server would be a [Rest or Representational State Transfer](https://de.wikipedia.org/wiki/Representational_State_Transfer) Server.

which basically means, the client (unity) request or sends information to the server (Django).

  

For the unity part it makes sense to have one specific object to handle all the server interaction, so that the single files of your project don't get too long by copy pasting the same code or to prevent mistakes like typos etc.

  

> [!info]
> In the project it is the *Assets/Scripts/ServerClasses/ServerCaller.cs*

  

#### Unity send data to server

#TODO code changed!

```cs
public IEnumerator GenericSend(string url,  Dictionary<string,object> values, ServerRequestCallBack callback=null)

    {

        using (UnityWebRequest www = UnityWebRequest.Post(url , JsonConvert.SerializeObject(values), "application/json"))

        {

            yield return www.SendWebRequest();

            if (www.result != UnityWebRequest.Result.Success)

            {

                Debug.Log(www.error);

            }

            else

            {

                callback?.Invoke();

                Debug.Log("first: " +www.downloadHandler.text);

            }

        }

    }

```

This is the "basic" way to send data to the server

example for calling:

```cs    

StartCoroutine(GenericSend("http://127.0.0.1:8000/rest/echo/",new Dictionary<string, object>() { { "username", "daw" } },DelegateTest));

```

> [!note] Coroutines
>[Unity - Manual: Coroutines (unity3d.com)](https://docs.unity3d.com/Manual/Coroutines.html)

  

>[!info]- Code Explained
>- **string url**: The url is selfexplanatory.
>- **Dictionary<string,object> values**: The dictionary is for the values you want to send.
>>[!info] In general it is easier to use a structure like json or XML to send the data, that way we can use libraries etc. and don't need a custom parser!
> - **ServerRequestCallBack callback=null**: This is a callback function.
>>[!info] You can call any function of your logic based on the data.   Why? ->Prevent copy pasting/confusion from copy pasting the same code multiple times.

  

To receive the data it is under the `www.downloadHandler.text`

see line => Debug.Log("first: " +www.downloadHandler.text);

  
  

#### Django side:

#TODO add picture

>[!info] *Short description where the url goes through.*
First the request from unity goes to each Middleware which is under `django_part->django_part->settings.py->MIDDLEWARE XY`.
after that the request goes to `django_part->django_part-> urls.py`
depending on which subdomain you go it goes to the respective url files under `django_part-> WSSGTemplate`
since the code before calls `http://127.0.0.1:8000/rest/echo/` the localhost under **/rest/echo/**. The url will search for the "echo/" part since the rest part is used by the other urls.py file.
=> now your logic will be executed e.g `django_part->WSSGTemplate->views_basic.py`

  #TODO old code

```py
async def echo(request):

    print(request.body)

    temp=utilities.extract_request_values(request,"username")

    print(f"{temp}")

    return HttpResponse(f"{temp}")

    pass

```

  

>[!info]- Code Explained
>**request** as parameter.
> after that it just gets print out to the console as well as being returned as an HttpResponse.
> This Response will come out on Unity side with the `www.downloadHandler.text`line.
> this is the case for the asgi version otherwise it would be in   *request.body*

  

Examples what should happen with the data etc.

e.g login, signup function.

  

first the signup function:

For that we need to send three variables (username, password1, password2).\

The password is needed two times for django, since it should normally be an web UI Interface, where you need to type in the password again for security.

  

```py

# signup function from template with an extra condition for better user experience

def signup(request):

    print("adw")

    if request.method != 'POST':

        return HttpResponse(f'incorrect request method.')

  

    # Instead of checking for the form data ourselves, we use the already

    # existing UserCreationForm.

    form = UserCreationForm(request.POST)

    if not form.is_valid():

        return HttpResponse(f'invalid form: {form}')

  

    # This creates a user from that form

    form.save()

  

    #extract the values

    username = utilities.extract_request_values(request, 'username')

    password = utilities.extract_request_values(request, 'password1')

  

    # We don't have to check if the username and password are correct

    # because we just created that exact user.

    user = authenticate(username=username, password=password)

    login(request, user)

    # Create the user's player

    player = Player(user=user,  name=username)

    # Don't forget to save at the end of all the changes to table contents

    player.save()

    return HttpResponse('0: successful signup')

```

>[!info]
>We could in theory only use the provided User structure by Django, but since one may need to extend it or use other ways to identify unique users, using an own Player Class makes sense.

  
  

These Classes which are modeled in django under `django_part-> WSSGTemplate-> models.py` need to have the same variable names as their Unitypart `Assets-> Scripts->ServerClasses-> ServerXY.cs`

>[!info]
> lines with
>```
>var responseData = JsonConvert.Deserialize<ServerXY>(jsonResponse)
>DoStuff(responseData.id);
>```
>are easier to understand than:
>```
>var responseData= JsonConvert.Deserialize<JObject>(jsonResponse);
>DoStuff(responseData["id"]); //JArray if it's a List
>```
>AUTOCOMPLETE POSSIBLE!

  
  
  

### Websockets

Now to the new part (if you are familiar with rest or the other template).

  

First, what are websockets? [WebSocket – Wikipedia](https://de.wikipedia.org/wiki/WebSocket#Vorteile_gegen%C3%BCber_reinem_HTTP)

basically you have a continuous connection to the server. This way you can directly receive data as client without asking the server.

  

For Example the server can repeatetly send requests every second to the clients for an clock update with just ONE connection.

  

Another Example would be real time position tracking for combat or something similar.

  

Since the connection stays alive between the server and the clients. we can send messages to clients specifically or all clients (boardcast).

  

For this functionality we can use the [channels](https://channels.readthedocs.io/en/latest/topics/channel_layers.html#using-outside-of-consumers) of django.

  

under `django_part-> WSSGTemplate->websocket_scripts->consumer_basic_layer.py`

I provided following functionality:

The default methods of a AsyncWebsocketConsumer: "connect", "__init\__", "disconnect", "receive", "chat_message".

As well as:

- send_message_to_client: Wraps the self.send function with the communication structure mentioned before.

#TODO link

- send_broadcast_message: with the communication structure sends a message to ALL consumers in a room (self.room_group_name)

- check_command: in combination with the self.commands variable it maps all Servermessages to their respective method, which is saved in self.commands.

  

example:

```py

#"identifier" | method

self.commands = {  

    "CREATE LOBBY": self.handle_create,  

    "JOIN LOBBY": self.handle_join,  

    "START LOBBY": self.handle_start_lobby,  

    "DEBUG": self.handle_debug,  

}

```

  

The most differences to the rest part are the following:

- using async variants of some methods with the `@database_sync_to_async` decorator

- sending messages instead of a HTTPResponse

- broadcasting messages instead of timers for periodic updates

  
  
  
  

# Resources:

[Django Channels — Channels 4.0.0 documentation](https://channels.readthedocs.io/en/latest/)

  

[Django documentation | Django documentation | Django (djangoproject.com)](https://docs.djangoproject.com/en/4.2/)

  

[sta/websocket-sharp: A C# implementation of the WebSocket protocol client and server (github.com)](https://github.com/sta/websocket-sharp)

  

[Serveo: expose local servers to the internet using SSH](http://serveo.net/#alternatives)

  
  

#TODO

Django:

- [ ] ```py
def get_friend_request(player_name, friend_name):  
try:  
return FriendRequest.objects.get(requestor__name=player_name, receiver__name=friend_name)  
except:  
try:  
return FriendRequest.objects.get(requestor__name=friend_name, receiver__name=player_name)  
except:  
return None
```
is disgusting
try
```py
return FriendRequest.objects.get(  
(Q(requestor__name=player_name) & Q(receiver__name=friend_name)) |  
(Q(requestor__name=friend_name) & Q(receiver__name=player_name))  
)
```

  

- [ ] make setter more generic with possibilty for partial updating, instance of Foreignkey or ManyToManyField!

  

- [ ] get, set, getall should not return an HTTPResponse!

  

- [ ] views_lobby -> set_lobby_by_id

- [ ] some unnecessary code??

  

- [ ] Websocket checks!

  

- [ ] Rewrite chat!

- [ ] delete unnecessary files